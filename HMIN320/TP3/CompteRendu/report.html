<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>HMIN320 Vision, r√©alit√©s virtuelle et augment√©e</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-light">
        <h1 id="hmin320-vision-r√©alit√©s-virtuelle-et-augment√©e">HMIN320 Vision, r√©alit√©s virtuelle et augment√©e</h1>
<p>On reprend la suite du TP1, et on y apporte quelques am√©liorations.</p>
<h2 id="cr√©ation-dun-niveau-simple">Cr√©ation d'un niveau simple</h2>
<p>On utilise probuilder afin de cr√©er un niveau de plateforme √† terminer</p>
<img src="img\level.png" width="800">
<h2 id="cam√©ra">Cam√©ra</h2>
<p>Pour permettre au joueur de d√©couvrir son environnement, on lui donne un meilleur contr√¥le sur la cam√©ra √† l'aides des <em>Fl√®ches Directionnelles</em>.
On utilise la package <strong>Cin√©machine</strong> pour la gestion des cam√©ras.</p>
<p>On s√©pare notre joueur en deux objets : une cible pour la cam√©ra et le corps du joueur.</p>
<img src="img\camera.png" width="800">
<p>On attache ensuite notre <em>Follow Target</em> √† notre cam√©ra virtuelle, et on utilise le mode <em>3rd Person Follow</em>.</p>
<h4 id="playercontrollercs">PlayerController.cs</h4>
<pre><code class="language-CSharp"><div><span class="hljs-comment">// Input Event</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLookAround</span>(<span class="hljs-params">InputAction.CallbackContext ctx</span>)</span>
{
    _inputLookVector = ctx.ReadValue&lt;Vector2&gt;();
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LookAround</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">if</span> (_followTransform != <span class="hljs-literal">null</span>)
    {
        _followTransform.rotation *= Quaternion.AngleAxis(_inputLookVector.x * _lookRotationSpeed.x * Time.fixedDeltaTime, Vector3.up);
        _followTransform.rotation *= Quaternion.AngleAxis(_inputLookVector.y * _lookRotationSpeed.y * Time.fixedDeltaTime, Vector3.right);

        ResetRollAndClampCameraAngles();

        <span class="hljs-comment">// When the player moves, align him with the camera angle</span>
        <span class="hljs-keyword">if</span> (_localSpeed.x != <span class="hljs-number">0.0f</span> || _localSpeed.z != <span class="hljs-number">0.0f</span>)
        {
            transform.rotation = Quaternion.Euler(<span class="hljs-number">0.0f</span>, _followTransform.eulerAngles.y, <span class="hljs-number">0.0f</span>);
            _followTransform.localEulerAngles = <span class="hljs-keyword">new</span> Vector3(angles.x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        }
    }
}
</div></code></pre>
<p>On peu ainsi d√©placer librement la cam√©ra autour du joueur.<br>
<img src="img\camera_view.png" width="800"></p>
<h3 id="vis√©e">Vis√©e</h3>
<p>En pr√©paration d'un √©ventuel syst√®me de vis√©e, on cr√©e une deuxi√®me cam√©ra virtuelle plac√©e au niveau de l'√©paule du joueur, et on cr√©er une transition lors du maintiens de la touche de vis√©e ajout√©e √† l'<em>ActionMap</em> : <code>[Left Shift]</code></p>
<h4 id="playercontrollercs-1">PlayerController.cs</h4>
<pre><code class="language-CSharp"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnAim</span>(<span class="hljs-params">InputAction.CallbackContext ctx</span>)</span>
{
    <span class="hljs-keyword">if</span> (ctx.started)
    {
        _mainCamera.SetActive(<span class="hljs-literal">false</span>);
        _aimCamera.SetActive(<span class="hljs-literal">true</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctx.canceled)
    {
        _mainCamera.SetActive(<span class="hljs-literal">true</span>);
        _aimCamera.SetActive(<span class="hljs-literal">false</span>);
    }
}
</div></code></pre>
<img src="img\camera_aim.gif" width="800">
<h2 id="am√©lioration-du-saut">Am√©lioration du Saut</h2>
<p>Dans un premier temps, nous ajoutons les animations de saut.</p>
<img src="img\jump_anim.png" width="800">
<p>Ensuite, nous allons revoir la physique du saut.
En effet, actuellement le saut forme une parabole car nous utilisons les lois de la physique classique, cependant, ce n'est pas le plus agr√©able √† manier pour un joueur.<br>
Une conf√©rence GDC a √©t√© donn√©e sur ce sujet et est tr√®s int√©ressante.</p>
<img src="img\jump.png" width="800">
<h4 id="playercontrollercs-2">PlayerController.cs</h4>
<pre><code class="language-CSharp"><div>_localSpeed.y -= g * dt * (_localSpeed.y &lt; <span class="hljs-number">0.0f</span> ? _fallMultiplier : <span class="hljs-number">1.0f</span>);
</div></code></pre>
<p><strong>GDC Reference</strong> <a href="http://www.mathforgameprogrammers.com/gdc2016/GDC2016_Pittman_Kyle_BuildingABetterJump.pdf">Building a better jump üîó</a></p>
<p>Enfin, on ajoute deux √©l√©ments suppl√©mentaires:</p>
<ul>
<li>On limite la vitesse de chute, afin de simuler la r√©sistance de l'air et avoir un meilleur contr√¥le de celles ci</li>
<li>On ajoute un court d√©lai (~0.1s) qui permet au joueur d'effectuer un saut m√™me apr√®s √™tre tomb√© d'une plateforme</li>
</ul>
<p>La deuxi√®me solution permet d'√©viter les situations frustrantes pour le joueur, o√π celui ci appuie un peu trop tard en bordure de plateforme et tombe dans le vide.</p>
<p><strong>Limitation de la vitesse de chute</strong></p>
<pre><code class="language-CSharp"><div>_localSpeed.y = Mathf.Max(_localSpeed.y, -_maximumFallSpeed);
</div></code></pre>
<p><strong>D√©lai pour le saut</strong></p>
<pre><code class="language-CSharp"><div><span class="hljs-keyword">if</span> (!_Controller.isGrounded)
{
    _timeElapsedSinceLastGrounded += dt;
}
<span class="hljs-keyword">else</span>
{
    _timeElapsedSinceLastGrounded = <span class="hljs-number">0.0f</span>;
}
</div></code></pre>
<pre><code class="language-CSharp"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnJump</span>(<span class="hljs-params">InputAction.CallbackContext ctx</span>)</span>
{
    <span class="hljs-comment">// We can jump within a short delay after leaving the ground</span>
    <span class="hljs-keyword">if</span> (ctx.started &amp;&amp; _timeElapsedSinceLastGrounded &lt; _jumpPermissiveExtraTime)
    {
        _localSpeed.y = _jumpForce;
        _Animator.SetTrigger(<span class="hljs-string">"Jump"</span>);
    }
}
</div></code></pre>
<h2 id="cin√©matique-dintroduction">Cin√©matique d'introduction</h2>
<p>On souhaite ajouter une cin√©matique d'introduction √† notre jeu.
Dans un premier temps, on cr√©er une nouvelle <em>Cam√©ra Virtuelle (Cin√©machine)</em> et on cr√©er un <em>Cin√©machine Smooth Path</em>
On ajoute le composant <em>Cinemachine Dolly Cart</em> √† notre cam√©ra virtuelle et on lui mets une vitesse de 10m/s.</p>
<img src="img\intro_path.png" width="800">
<p>Ensuite, on cr√©er une timeline qui se d√©clenchera d√®s le d√©but du niveau.
On lui ajoute deux activations tracks : on active dans un premier temps notre cam√©ra d'introduciton, pour on active ensuite celle du joueur.</p>
<img src="img\timeline.png" width="800">
<p>Et voil√† ! On a une superbe cin√©matique de d√©but de niveau ! Celle ci est tr√®s basique mais on peut l'approfondir avec l'outil Timeline en ajoutant divers effets.</p>
<p><em>N'h√©sitez pas √† tester le jeu pour voir la cin√©matique</em></p>
<h2 id="ajouts-suppl√©mentaires">Ajouts suppl√©mentaires</h2>
<p>Voici une liste de petits ajo√ªts suppl√©mentaires:</p>
<ul>
<li>Correction d'un bug permettant d'obtenir plusieurs pi√®ces d'un coup</li>
<li>Ajo√ªt des bruits de pas lorsque le joueur cours sur le sol</li>
<li>Fixation de la vitesse lorsque le joueur est sur le sol, celle ci est calcul√©e de sorte que le joueur puisse descendre les pentes sans accoups.</li>
</ul>

    </body>
    </html>